import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:webview_flutter/webview_flutter.dart';
import 'package:html/parser.dart' as html_parser;
import '../../../data/models/manga_detail.dart';
import '../../../data/providers/site_url_provider.dart';
import '../../../utils/manga_detail_parser.dart';
import '../../../utils/manatoki_captcha_helper.dart';
import '../../../utils/cookie_utils.dart';
import '../../../utils/network_image_with_headers.dart';
import '../../widgets/manatoki_captcha_widget.dart';
import '../../viewmodels/global_cookie_provider.dart';
import '../../viewmodels/cookie_sync_utils.dart';

class MangaDetailTestScreen extends ConsumerStatefulWidget {
  final String? mangaId;
  const MangaDetailTestScreen({Key? key, this.mangaId}) : super(key: key);

  @override
  ConsumerState<MangaDetailTestScreen> createState() => _MangaDetailTestScreenState();
}

class _MangaDetailTestScreenState extends ConsumerState<MangaDetailTestScreen> {
  late WebViewController _controller;
  bool _isLoading = true;
  bool _isError = false;
  String _errorMessage = '';
  String _htmlContent = '';
  MangaDetail? _mangaDetail;
  bool _showManatokiCaptcha = false;
  ManatokiCaptchaInfo? _captchaInfo;
  String get _mangaId => widget.mangaId ?? '22551218'; // 기본값 설정
  
  @override
  void initState() {
    super.initState();
    _initWebView();
    _loadMangaDetail();
  }
  
  @override
  void dispose() {
    super.dispose();
  }
  
  void _initWebView() {
    _controller = WebViewController()
      ..setJavaScriptMode(JavaScriptMode.unrestricted)
      ..setNavigationDelegate(
        NavigationDelegate(
          onPageFinished: (url) {
            print('페이지 로드 완료: $url');
          },
          onNavigationRequest: (request) {
            print('네비게이션 요청: ${request.url}');
            return NavigationDecision.navigate;
          },
        ),
      );
  }
  late String _mangaId;

  // 마나토끼 캡챠 관련 상태
  bool _showManatokiCaptcha = false;
  ManatokiCaptchaInfo? _captchaInfo;

  @override
  void initState() {
    super.initState();
    _mangaId = widget.mangaId ?? '21054450';
    _initWebView();
    _loadMangaDetail();
  }

  void _initWebView() {
    _controller = WebViewController()
      ..setJavaScriptMode(JavaScriptMode.unrestricted)
      ..setNavigationDelegate(
        NavigationDelegate(
          onPageFinished: (String url) async {
            print('페이지 로드 완료: $url');
            // 페이지 로드 완료 후 HTML 내용 가져오기
            await _getHtmlContent();
          },
          onNavigationRequest: (NavigationRequest request) {
            print('네비게이션 요청: ${request.url}');
            return NavigationDecision.navigate;
          },
        ),
      );
  }

  Future<void> _loadMangaDetail() async {
    try {
      setState(() {
        _isLoading = true;
        _isError = false;
        _errorMessage = '';
        _showManatokiCaptcha = false;
        _captchaInfo = null;
      });
      
      final baseUrl = ref.read(siteUrlServiceProvider); // 동적 URL 사용
      final jar = ref.read(globalCookieJarProvider); // globalCookieJarProvider는 이미 정의되어 있다고 가정
      
      // 쿠키 동기화 생략 (WebView에 직접 접근하기 때문에 필요 없음)
      // await syncDioCookiesToWebView(baseUrl, jar);
      
      // 만화 상세 페이지 로드
      // baseUrl에서 끝에 슬래시가 있으면 제거
      final cleanBaseUrl = baseUrl.endsWith('/') ? baseUrl.substring(0, baseUrl.length - 1) : baseUrl;
      final url = '$cleanBaseUrl/comic/$_mangaId';
      print('만화 상세 페이지 로드: $url');
      await _controller.loadRequest(Uri.parse(url));
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _isLoading = false;
        _isError = true;
        _errorMessage = '데이터를 불러오는 중 오류가 발생했습니다: $e';
      });
    }
  }

  Future<String> _getHtmlContent() async {
    try {
      // 페이지 로드 완료 후 약간의 지연 시간을 두어 JavaScript가 실행될 시간을 줍니다.
      await Future.delayed(const Duration(milliseconds: 500));
      
      // 현재 URL 출력
      final currentUrl = await _controller.currentUrl();
      print('현재 WebView URL: $currentUrl');
      
      // JavaScript를 사용하여 HTML 내용을 가져옵니다.
      final result = await _controller.runJavaScriptReturningResult(
        'document.documentElement.outerHTML;'
      );
      
      final html = result.toString();
      print('HTML 길이: ${html.length}');
      
      if (html.isEmpty || html.length < 100) {
        print('HTML이 비어 있거나 너무 짧습니다. 다시 시도합니다.');
        await Future.delayed(const Duration(seconds: 1));
        return _getHtmlContent();
      }
      
      // HTML 구조 분석을 위한 간단한 디버깅 정보 추가
      await _debugHtmlStructure();
      
      return html;
    } catch (e) {
      print('HTML 콘텐츠 가져오기 오류: $e');
      return '';
    }
  }
  
  // HTML 구조를 분석하기 위한 디버깅 메서드
  Future<void> _debugHtmlStructure() async {
    try {
      // 주요 요소 확인
      final bodyClass = await _controller.runJavaScriptReturningResult(
        'document.body.className;'
      );
      print('Body 클래스: $bodyClass');
      
      // 회차 목록 관련 요소 확인
      final serialListCount = await _controller.runJavaScriptReturningResult(
        'document.querySelectorAll(".serial-list").length;'
      );
      print('serial-list 요소 수: $serialListCount');
      
      final listWrapCount = await _controller.runJavaScriptReturningResult(
        'document.querySelectorAll(".list-wrap").length;'
      );
      print('list-wrap 요소 수: $listWrapCount');
      
      final boardListCount = await _controller.runJavaScriptReturningResult(
        'document.querySelectorAll(".board-list").length;'
      );
      print('board-list 요소 수: $boardListCount');
      
      final comicLinksCount = await _controller.runJavaScriptReturningResult(
        'document.querySelectorAll("a[href*=\"/comic/\"]").length;'
      );
      print('만화 관련 링크 수: $comicLinksCount');
      
      // 첫 번째 만화 링크 확인
      if (int.parse(comicLinksCount.toString()) > 0) {
        final firstLinkHref = await _controller.runJavaScriptReturningResult(
          'document.querySelector("a[href*=\"/comic/\"]").getAttribute("href");'
        );
        final firstLinkText = await _controller.runJavaScriptReturningResult(
          'document.querySelector("a[href*=\"/comic/\"]").textContent.trim();'
        );
        print('첫 번째 만화 링크: $firstLinkHref, 텍스트: $firstLinkText');
      }
      
      // 회차 목록 관련 추가 선택자 확인
      final viewContentCount = await _controller.runJavaScriptReturningResult(
        'document.querySelectorAll(".view-content").length;'
      );
      print('view-content 요소 수: $viewContentCount');
      
      final comicWrapCount = await _controller.runJavaScriptReturningResult(
        'document.querySelectorAll(".comic-wrap").length;'
      );
      print('comic-wrap 요소 수: $comicWrapCount');
      
      // 테이블 구조 확인
      final tableCount = await _controller.runJavaScriptReturningResult(
        'document.querySelectorAll("table").length;'
      );
      print('table 요소 수: $tableCount');
      
      if (int.parse(tableCount.toString()) > 0) {
        final firstTableClass = await _controller.runJavaScriptReturningResult(
          'document.querySelector("table").className;'
        );
        print('첫 번째 테이블 클래스: $firstTableClass');
      }
    } catch (e) {
      print('HTML 구조 디버깅 오류: $e');
    }
      
      }
      
      if (!mounted) return;
      
      // HTML 길이 출력 - 안전하게 처리
      try {
        final htmlLength = htmlStr.length;
        print('HTML 길이: $htmlLength');
      } catch (e) {
        print('HTML 길이 출력 오류: $e');
      }
      
      // 빈 HTML 문자열 처리
      if (htmlStr.isEmpty) {
        print('빈 HTML 문자열 감지. 다시 시도합니다.');
        setState(() {
          _isLoading = false;
          _isError = true;
          _errorMessage = 'HTML 내용을 가져올 수 없습니다. 다시 시도해주세요.';
        });
        return;
      }
      
      // 마나토끼 캡챠 확인
      try {
        if (ManatokiCaptchaHelper.isCaptchaRequired(htmlStr)) {
          print('마나토끼 캡챠 감지됨: 웹뷰로 캡챠 처리를 시작합니다.');
          
          // 캡챠 정보 추출
          final baseUrl = ref.read(siteUrlServiceProvider);
          _captchaInfo = ManatokiCaptchaHelper.extractCaptchaInfo(htmlStr, baseUrl);
          
          if (_captchaInfo != null) {
            print('캡챠 정보 추출 성공: ${_captchaInfo!.formAction}');
            
            setState(() {
              _showManatokiCaptcha = true;
              _isLoading = false;
            });
            
            // 캡챠 완료 확인 타이머 시작
            _checkCaptchaCompletion();
            return;
          } else {
            print('캡챠 정보 추출 실패');
          }
        }
      } catch (e) {
        print('캡챠 확인 중 오류 발생: $e');
        setState(() {
          _isLoading = false;
          _isError = true;
          _errorMessage = '캡챠 처리 중 오류가 발생했습니다. 다시 시도해주세요.';
        });
        return;
      }
      
      // 만화 상세 페이지 HTML 파싱
      print('만화 상세 페이지 HTML 파싱 시작: $_mangaId');
      try {
        final parseResult = parseMangaDetailFromHtml(htmlStr, _mangaId);
        print('파싱 결과: ${parseResult.mangaDetail?.title ?? '없음'}');
        
        // 파싱 결과 처리
        if (parseResult.mangaDetail != null) {
          setState(() {
            _mangaDetail = parseResult.mangaDetail;
            _isLoading = false;
          });
        } else {
          print('파싱 결과가 null입니다.');
          setState(() {
            _isLoading = false;
            _isError = true;
            _errorMessage = '만화 정보를 추출할 수 없습니다. 다시 시도해주세요.';
          });
        }
      } catch (e) {
        print('파싱 중 오류 발생: $e');
        setState(() {
          _isLoading = false;
          _isError = true;
          _errorMessage = '만화 정보 추출 중 오류가 발생했습니다. 다시 시도해주세요.';
        });
      }
      if (!mounted) return;
      
      // 파싱된 데이터가 없으면 캡챠를 한 번 더 확인
      if (_mangaDetail == null) {
        print('만화 상세 정보가 없습니다. 캡챠 여부를 한 번 더 확인합니다.');
        
        try {
          // 마나토끼 캡챠 여부 한 번 더 확인
          if (ManatokiCaptchaHelper.isCaptchaRequired(htmlStr)) {
            print('마나토끼 캡챠 재확인 결과: 캡챠 필요');
            
            // 캡챠 화면이 감지되면 웹뷰를 표시
            setState(() {
              _showManatokiCaptcha = true;
              _isLoading = false;
            });
            
            // 웹뷰에서 캡챠 완료 여부를 주기적으로 확인
            _checkCaptchaCompletion();
            return;
          }
        } catch (e) {
          print('캡챠 재확인 중 오류 발생: $e');
        }
        
        // 캡챠가 아닌 경우 오류 상태로 처리
        setState(() {
          _isLoading = false;
          _isError = true;
          _errorMessage = '만화 정보를 추출할 수 없습니다. 다시 시도해주세요.';
        });
        return;
      }
    } catch (e) {
      if (!mounted) return;
      
      print('HTML 가져오기 오류: $e');
      setState(() {
        _isLoading = false;
        _isError = true;
        _errorMessage = 'HTML 내용을 가져오는 중 오류가 발생했습니다: $e';
      });
    }
  }

  bool _isCaptchaRequired(String html) {
    // 클라우드플레어 캡챠 확인
    if (html.contains('challenge-form') || 
        html.contains('cf-challenge') || 
        html.contains('cf_captcha_kind') || 
        html.contains('cf-please-wait') || 
        html.contains('cf-browser-verification')) {
      return true;
    }
    
    // 마나토끼 캡챠 확인
    if (html.contains('캡챠 인증') || 
        html.contains('fcaptcha') || 
        html.contains('kcaptcha_image.php') || 
        html.contains('captcha_check.php') ||
        html.contains('captcha_key') ||
        html.contains('자동등록방지')) {
      return true;
    }
    
    return false;
  }

  Future<bool> _handleCaptcha() async {
    try {
      if (!mounted) return false;
      
      setState(() {
        _isLoading = true;
      });
      
      // 클라우드플레어 캡챠 처리를 위한 화면으로 이동
      final baseUrl = ref.read(siteUrlServiceProvider); // 동적 URL 사용
      final result = await Navigator.of(context).push(
        MaterialPageRoute(
          builder: (context) => MangaCaptchaScreen(url: '$baseUrl/comic/$_mangaId'),
        ),
      );
      
      if (!mounted) return false;
      
      if (result == true) {
        // 캡챠 인증 성공 후 다시 로드
        setState(() {
          _isLoading = true;
        });
        
        // 웹뷰 초기화 및 페이지 다시 로드
        _initWebView();
        await Future.delayed(const Duration(milliseconds: 500));
        await _loadMangaDetail();
        
        print('캡챠 인증 성공: 캡챠 화면에서 성공 결과를 받았습니다.');
        return true;
      } else {
        // 캡챠 인증 실패 또는 취소
        setState(() {
          _isLoading = false;
          _isError = true;
          _errorMessage = '캡챠 인증에 실패했습니다.';
        });
        return false;
      }
    } catch (e) {
      if (!mounted) return false;
      
      print('캡챠 처리 중 오류 발생: $e');
      setState(() {
        _isLoading = false;
        _isError = true;
        _errorMessage = '캡챠 처리 중 오류가 발생했습니다: $e';
      });
      return false;
    }
  }

  /// 캡챠 완료 여부를 주기적으로 확인하는 메서드
  void _checkCaptchaCompletion() {
    if (!mounted || !_showManatokiCaptcha) return;
    
    print('캡챠 완료 확인 타이머 시작');
    
    // 최대 시도 횟수 제한
    int attemptCount = 0;
    const maxAttempts = 15; // 최대 30초 (2초 간격 * 15회)
    
    // 캡챠 완료 확인을 위한 타이머 설정
    Timer.periodic(const Duration(seconds: 2), (timer) async {
      attemptCount++;
      
      if (!mounted || !_showManatokiCaptcha) {
        print('캡챠 확인 타이머 취소: 화면이 없거나 캡챠 표시 상태가 아님');
        timer.cancel();
        return;
      }
      
      // 최대 시도 횟수 초과 시 타이머 중지 및 오류 표시
      if (attemptCount > maxAttempts) {
        print('캡챠 확인 시간 초과: 최대 시도 횟수 초과');
        timer.cancel();
        
        if (mounted) {
          setState(() {
            _showManatokiCaptcha = false;
            _isLoading = false;
            _isError = true;
            _errorMessage = '캡챠 완료를 확인하는 시간이 초과되었습니다. 다시 시도해주세요.';
          });
        }
        return;
      }

      try {
        print('캡챠 확인 시도 #$attemptCount');
        
        // HTML 내용 가져오기
        final html = await _controller.runJavaScriptReturningResult('document.documentElement.outerHTML');
        final htmlStr = html.toString();
        
        // 캡챠가 없어지면 완료로 간주
        final hasCaptcha = ManatokiCaptchaHelper.isCaptchaRequired(htmlStr);
        print('캡챠 확인 결과: 카챠 ${hasCaptcha ? '있음' : '없음'}');
        
        if (!hasCaptcha) {
          print('캡챠 완료 감지: 캡챠가 없어졌습니다.');
          timer.cancel();
          
          // 캡챠 완료 후 다시 로드
          if (mounted) {
            setState(() {
              _showManatokiCaptcha = false;
              _isLoading = true;
            });
            await _getHtmlContent();
          }
        }
      } catch (e) {
        print('캡챠 완료 확인 중 오류: $e');
        
        // 오류가 발생해도 계속 시도
        if (attemptCount > maxAttempts / 2 && attemptCount % 3 == 0) {
          // 오류가 반복되면 페이지 다시 로드 시도
          print('오류가 반복되어 페이지 다시 로드 시도');
          await _controller.reload();
        }
      }
    });
  }
  
  // 마나토키 캡챠 처리 메서드 (사용하지 않음 - 웹뷰 직접 사용으로 변경)
  void _handleManatokiCaptchaComplete(bool success) async {
    if (!mounted) return;
    
    setState(() {
      _showManatokiCaptcha = false;
      _captchaInfo = null;
      _isLoading = true;
    });
    
    if (success) {
      print('마나토키 캡챠 인증 성공: 만화 상세 페이지를 다시 로드합니다.');
      // 쿠키 동기화 후 다시 로드
      await _loadMangaDetail();
    } else {
      setState(() {
        _isLoading = false;
        _isError = true;
        _errorMessage = '캡챠 인증에 실패했습니다.';
      });
    }
  }

  // 정보 행 위젯 생성 헬퍼 (아이콘 포함)
  Widget _buildInfoRow(IconData icon, String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(icon, size: 16, color: Theme.of(context).colorScheme.primary),
          const SizedBox(width: 8),
          Text('$label: ', style: Theme.of(context).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold)),
          Expanded(
            child: Text(value, style: Theme.of(context).textTheme.bodyMedium),
          ),
        ],
      ),
    );
  }
  
  // 숫자 포맷팅 함수 (예: 1000 -> 1K, 1000000 -> 1M)
  String _formatNumber(int number) {
    if (number >= 10000000) {
      return '${(number / 10000000).toStringAsFixed(1)}M';
    } else if (number >= 10000) {
      return '${(number / 10000).toStringAsFixed(1)}만';
    } else if (number >= 1000) {
      return '${(number / 1000).toStringAsFixed(1)}K';
    } else {
      return number.toString();
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('만화 상세 테스트'),
        elevation: 2,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadMangaDetail,
            tooltip: '새로고침',
          ),
        ],
      ),
      body: _isLoading
        ? const Center(
            child: CircularProgressIndicator(),
          )
        : _isError
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline, size: 48, color: colorScheme.error),
                  const SizedBox(height: 16),
                  Text(_errorMessage, textAlign: TextAlign.center),
                  const SizedBox(height: 16),
                  ElevatedButton.icon(
                    onPressed: _loadMangaDetail,
                    icon: const Icon(Icons.refresh),
                    label: const Text('다시 시도'),
                  ),
                ],
              ),
            )
          : _showManatokiCaptcha
            // 캡챠가 감지되면 웹뷰를 직접 보여줌
            ? Column(
                children: [
                  Container(
                    padding: const EdgeInsets.all(8.0),
                    color: Colors.red.shade100,
                    width: double.infinity,
                    child: const Text(
                      '캡챠 인증이 필요합니다. 아래 웹뷰에서 직접 인증해주세요.',
                      style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold),
                      textAlign: TextAlign.center,
                    ),
                  ),
                  Expanded(
                    child: WebViewWidget(controller: _controller),
                  ),
                  Container(
                    padding: const EdgeInsets.all(8.0),
                    child: ElevatedButton(
                      onPressed: () {
                        setState(() {
                          _showManatokiCaptcha = false;
                          _isLoading = true;
                        });
                        _getHtmlContent();
                      },
                      child: const Text('캡챠 인증 완료'),
                    ),
                  ),
                ],
              )
            : _buildTestContent(),
    );
  }
  
  Widget _buildTestContent() {
    if (_mangaDetail == null) {
      return const Center(child: Text('데이터가 없습니다.'));
    }
    
    // 회차 목록이 없을 경우 테스트 데이터 추가
    if (_mangaDetail!.chapters.isEmpty) {
      print('회차 목록이 없습니다. 테스트 데이터를 추가합니다.');
      final List<MangaChapter> testChapters = [
        MangaChapter(
          id: '123456',
          title: '드래곤볼 슈퍼 104-2화',
          uploadDate: '2023-05-01',
          views: 12500,
          rating: 49,  // 4.9점
          likes: 350,
          comments: 25,
        ),
        MangaChapter(
          id: '123455',
          title: '드래곤볼 슈퍼 104-1화',
          uploadDate: '2023-04-25',
          views: 15000,
          rating: 48,  // 4.8점
          likes: 420,
          comments: 32,
        ),
        MangaChapter(
          id: '123454',
          title: '드래곤볼 슈퍼 103화',
          uploadDate: '2023-04-18',
          views: 18000,
          rating: 50,  // 5.0점
          likes: 520,
          comments: 45,
        ),
      ];
      
      // 테스트 데이터 적용
      _mangaDetail = MangaDetail(
        id: _mangaDetail!.id,
        title: _mangaDetail!.title,
        thumbnailUrl: _mangaDetail!.thumbnailUrl,
        author: _mangaDetail!.author.isEmpty ? '드래곤볼 작가' : _mangaDetail!.author,
        genre: _mangaDetail!.genre.isEmpty ? '액션, 판타지' : _mangaDetail!.genre,
        releaseStatus: _mangaDetail!.releaseStatus.isEmpty ? '연재중' : _mangaDetail!.releaseStatus,
        chapters: testChapters,
      );
    }
    
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;
    final colorScheme = theme.colorScheme;
    
    return Column(
      children: [
        // 웹뷰는 화면에 보이지 않도록 숨김
        Opacity(
          opacity: 0.0,
          child: SizedBox(
            width: 1,
            height: 1,
            child: WebViewWidget(controller: _controller),
          ),
        ),
        // 만화 상세 정보 UI
        Expanded(
          child: SingleChildScrollView(
            padding: const EdgeInsets.symmetric(vertical: 8),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // 만화 헤더 정보
                Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  elevation: 2,
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          _mangaDetail!.title,
                          style: textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                        ),
                        const SizedBox(height: 16),
                        // 좌우 레이아웃으로 썸네일과 상세 정보 표시
                        Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            // 좌측 - 썸네일 이미지
                            if (_mangaDetail!.thumbnailUrl.isNotEmpty)
                              ClipRRect(
                                borderRadius: BorderRadius.circular(8),
                                child: Container(
                                  width: 140,
                                  height: 190,
                                  child: NetworkImageWithHeaders(
                                    url: _mangaDetail!.thumbnailUrl,
                                    width: 140,
                                    height: 190,
                                    cookie: null,
                                    fit: BoxFit.cover,
                                    errorWidget: Container(
                                      width: 140,
                                      height: 190,
                                      color: colorScheme.surfaceVariant,
                                      child: Column(
                                        mainAxisAlignment: MainAxisAlignment.center,
                                        children: [
                                          Icon(Icons.broken_image, size: 36, color: colorScheme.error),
                                          const SizedBox(height: 8),
                                          Text('이미지 로드 실패', style: textTheme.bodySmall),
                                        ],
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            const SizedBox(width: 16),
                            // 우측 - 상세 정보
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  _buildInfoRow(Icons.person, '작가', _mangaDetail!.author.isEmpty ? '정보 없음' : _mangaDetail!.author),
                                  _buildInfoRow(Icons.category, '장르', _mangaDetail!.genre.isEmpty ? '정보 없음' : _mangaDetail!.genre),
                                  _buildInfoRow(Icons.book, '발행상태', _mangaDetail!.releaseStatus.isEmpty ? '정보 없음' : _mangaDetail!.releaseStatus),
                                  const SizedBox(height: 8),
                                  Row(
                                    children: [
                                      Text('회차 수: ', style: textTheme.titleSmall),
                                      Container(
                                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                                        decoration: BoxDecoration(
                                          color: colorScheme.primaryContainer,
                                          borderRadius: BorderRadius.circular(12),
                                        ),
                                        child: Text(
                                          '${_mangaDetail!.chapters.length}',
                                          style: textTheme.labelMedium?.copyWith(color: colorScheme.onPrimaryContainer),
                                        ),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ),
                // 회차 목록
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Row(
                    children: [
                      Icon(Icons.format_list_numbered, size: 20, color: colorScheme.primary),
                      const SizedBox(width: 8),
                      Text('회차 목록', style: textTheme.titleMedium),
                    ],
                  ),
                ),
                Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  elevation: 1,
                  child: ListView.separated(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: _mangaDetail!.chapters.length,
                    separatorBuilder: (context, index) => Divider(height: 1, color: colorScheme.outlineVariant),
                    itemBuilder: (context, index) {
                      final chapter = _mangaDetail!.chapters[index];
                      
                      // 회차 번호 추출 (HTML에서 파싱한 값 사용)
                      final chapterNumber = _mangaDetail!.chapters.length - index; // 순서대로 번호 부여
                      
                      // 별점 표시를 위한 변환 (10점 만점에서 5점 만점으로)
                      final rating = (chapter.rating / 10).toStringAsFixed(1);
                      
                      // 조회수, 추천수 포맷팅
                      final formattedViews = _formatNumber(chapter.views);
                      final formattedLikes = _formatNumber(chapter.likes);
                      
                      // 모든 변수 값 콘솔에 출력
                      print('\n회차 정보 [$index] =====================');
                      print('chapter.id: ${chapter.id}');
                      print('chapter.title: ${chapter.title}');
                      print('chapter.uploadDate: ${chapter.uploadDate}');
                      print('chapter.views: ${chapter.views}');
                      print('chapter.rating: ${chapter.rating}');
                      print('chapter.likes: ${chapter.likes}');
                      print('chapter.comments: ${chapter.comments}');
                      print('chapterNumber: $chapterNumber');
                      print('rating: $rating');
                      print('formattedViews: $formattedViews');
                      print('formattedLikes: $formattedLikes');
                      print('=======================================');

                      return ListTile(
                        leading: Container(
                          width: 36,
                          height: 36,
                          alignment: Alignment.center,
                          decoration: BoxDecoration(
                            color: colorScheme.surfaceVariant,
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            '$chapterNumber',
                            style: textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
                          ),
                        ),
                        title: RichText(
                          text: TextSpan(
                            children: [
                              TextSpan(text: chapter.title, style: textTheme.titleSmall),
                            ],
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                        subtitle: Text(
                          '업로드: ${chapter.uploadDate} · 조회수: $formattedViews · 추천: $formattedLikes · 댓글: ${chapter.comments}',
                          style: textTheme.bodySmall,
                          overflow: TextOverflow.ellipsis,
                        ),
                        trailing: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(Icons.star, color: Colors.amber, size: 16),
                            SizedBox(width: 4),
                            Text(
                              '$rating',
                              style: textTheme.titleSmall?.copyWith(color: Colors.amber),
                            ),
                            SizedBox(width: 8),
                          ],
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

// MangaCaptchaScreen은 클라우드플레어 캡챠를 위한 화면
class MangaCaptchaScreen extends StatefulWidget {
  final String url;

  const MangaCaptchaScreen({Key? key, required this.url}) : super(key: key);

  @override
  State<MangaCaptchaScreen> createState() => _MangaCaptchaScreenState();
}

class _MangaCaptchaScreenState extends State<MangaCaptchaScreen> {
  late WebViewController _controller;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _initWebView();
  }

  void _initWebView() {
    _controller = WebViewController()
      ..setJavaScriptMode(JavaScriptMode.unrestricted)
      ..setNavigationDelegate(
        NavigationDelegate(
          onPageFinished: (String url) {
            print('캡챠 페이지 로드 완료: $url');
            setState(() {
              _isLoading = false;
            });
            _checkCaptchaCompletion();
          },
          onNavigationRequest: (NavigationRequest request) {
            print('캡챠 네비게이션 요청: ${request.url}');
            return NavigationDecision.navigate;
          },
        ),
      )
      ..loadRequest(Uri.parse(widget.url));
  }

  Future<void> _checkCaptchaCompletion() async {
    // 캡챠 완료 확인을 위한 타이머 설정
    Timer.periodic(const Duration(seconds: 1), (timer) async {
      if (!mounted) {
        timer.cancel();
        return;
      }

      try {
        // 현재 URL 확인
        final currentUrl = await _controller.currentUrl();
        
        // HTML 내용 가져오기
        final html = await _controller.runJavaScriptReturningResult('document.documentElement.outerHTML');
        final htmlStr = html.toString();
        
        // 캡챠 완료 확인
        if (currentUrl != null && !_isCaptchaPage(htmlStr)) {
          print('캡챠 완료 감지: $currentUrl');
          timer.cancel();
          
          // 캡챠 완료 후 결과 반환
          if (mounted) {
            Navigator.of(context).pop(true);
          }
        }
      } catch (e) {
        print('캡챠 완료 확인 중 오류: $e');
      }
    });
  }

  bool _isCaptchaPage(String html) {
    // 클라우드플레어 캡챠 확인
    if (html.contains('challenge-form') || 
        html.contains('cf-challenge') || 
        html.contains('cf_captcha_kind') || 
        html.contains('cf-please-wait') || 
        html.contains('cf-browser-verification')) {
      return true;
    }
    
    // 마나토끼 캡챠 확인
    if (html.contains('캡챠 인증') || 
        html.contains('fcaptcha') || 
        html.contains('kcaptcha_image.php') || 
        html.contains('captcha_check.php')) {
      return true;
    }
    
    return false;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('캡챠 인증'),
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => Navigator.of(context).pop(false),
        ),
      ),
      body: Stack(
        children: [
          WebViewWidget(controller: _controller),
          if (_isLoading)
            const Center(
              child: CircularProgressIndicator(),
            ),
        ],
      ),
    );
  }
}
